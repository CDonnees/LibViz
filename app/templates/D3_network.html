
{% extends "D3_network_infos.html" %}

{% block D3_graph %}
  
    <!-- div graph / dataviz -->
    <!--<div id="graphLayoutSVG" class="col-sm-8" >-->
      <!--<svg></svg>-->
    <!--</div>-->

  
{% endblock %}




{% block D3_js %}

  </div> <!-- ./end contents whole row  -->
  

    
  <!-- script D3.JS  -->
  <script type="text/javascript" src="https://d3js.org/d3.v4.min.js"></script>
  <script>
      
    // find width and height of parent html elements
    var contWidth  = document.getElementById('body').clientWidth;
    //var contWidth = document.documentElement.clientWidth;
    
    var contHeight = document.documentElement.clientHeight;
    //var contHeight = document.getElementById('body').clientHeight;
    
    // add the width and height attributes to the <svg>
    //var svg = d3.select("svg")
    //  .attr("width" , contWidth )
    //  .attr("height", contHeight )
    //  //.call(zoom) //////////
    //  ;
    
    
    // zooming / panning function 
    var zoom = d3.zoom()
      //.scaleExtent([1, 10])
      .on("zoom", zoomed)
      ;

    var dft_circle_stroke_w = "1.5px";
    var dft_line_stroke_w = "1.0px";
    
      
    // create svg
    var svg = d3.select("#containerLayout")
      .append("svg:svg")
      .attr("width" , contWidth - 15)
      .attr("height", contHeight - 90)
      .call(zoom)
      .on("dblclick.zoom", null)
      ;

    // canvas
    var svg = d3.select("svg"),
      width  = +svg.attr("width"),
      height = +svg.attr("height");
    
    //var tip = d3.tip()
    //  .attr('class', 'd3-tip')
    //  .offset([-10, 0])
    //  .html(function(d) {
    //    return "<strong>" + d.label + "</strong>";
    //  })
  
    //add the div for the tooltip
    var div = d3.select("body")
      .append("div")
      .attr("class", "panel panel-info tooltip")
      .style("opacity", 0) ;
    
    //var div = div.append("a");
    
    // add group for shapes in svg
    var vis = svg
      //.append('g')
      ;
    
    var links_g = vis.append('g')
      .attr("class", "links") ;

    var nodes_g = vis.append('g')
      .attr("class", "nodes") ;    
    
    function zoomed() {
      //vis.attr("transform", "translate(" + d3.event.translate + ")scale(" + d3.event.scale + ")");
      svg.attr("transform", d3.event.transform );
    }

    // normal drag function /////////////////////////////////////////
    var node_normal_drag = d3.drag()
      //.subject(dragsubject) /// sticky function not working ////////////////////////////////
      .on("start", dragstarted)
      .on("drag" , dragged    )
      .on("end"  , dragended  ) ;
      function dragstarted(d) {          
          if (!d3.event.active) simulation.alphaTarget(0.3).restart()
          //d3.select(this).classed("fixed", d.fixed = true);
          //simulation.fix(d3.event.subject);
          d.fx = d.x;
          d.fy = d.y;
      }
      function dragged(d) {
          //simulation.fix(d3.event.subject, d3.event.x, d3.event.y);
          d.fx = d3.event.x;
          d.fy = d3.event.y;
      }
      function dragended(d) {
          if (!d3.event.active) simulation.alphaTarget(0);
          //if (!d3.event.subject.fixed) simulation.unfix(d3.event.subject);
          d.fx = null;
          d.fy = null;
      }
      ;

    // function drag-pin down nodes ///////////////////////////////
    // from http://www.coppelia.io/2014/07/an-a-to-z-of-extra-features-for-the-d3-force-layout/
    var node_pin_drag = d3.drag()
            .on("start", dragstart_)
            .on("drag" , dragmove_)
            .on("end"  , dragend_);
      function dragstart_(d, i) {
          d3.forceSimulation().stop() // stops the force auto positioning before you start dragging
      }
      function dragmove_(d, i) {
          d.px += d3.event.dx;
          d.py += d3.event.dy;
          d.x += d3.event.dx;
          d.y += d3.event.dy;
      }
      function dragend_(d, i) {
          d.fixed = true; // of course set the node to fixed so the force doesn't include the node in its auto positioning stuff
          d3.forceSimulation().restart();
      }
      function releasenode_(d) {
          d.fixed = false; // of course set the node to fixed so the force doesn't include the node in its auto positioning stuff
          //force.resume();
      }


    //var color = d3.scaleOrdinal(d3.schemeCategory20);
    
    
    // create legend in div #legend on the fly ////////// NOT FINISHED YET //////////////////////////////
    var legendWidth  = document.getElementById('legend').clientWidth ;
    //var legendHeight = document.getElementById('legend').clientHeight;
    var legend = d3.select("#legend")
      .append("svg:svg")
      .attr("background-color", "black")
      .attr("width", legendWidth)
      .attr("height", 100) ;
    
    var nodeLegend = legend.append("g")
      .attr("class"   , "nodes_legend") ;
    // add circles for nodes_legend
    var spaceX  = 20 ;
    var spaceY  = 20 ;
    var legendR = 8  ;
    nodeLegend.append("circle")
      .attr("cx", spaceX )
      .attr("cy", spaceY )
      .attr("r", legendR )
      .style("fill", "black" ) //return color(d.{{glob.ns.type}})
    nodeLegend.append("text")
    
   
    // force parameters
    var simulation = d3.forceSimulation()
        .force("link"   , d3.forceLink().id(function(d) { return d.{{glob.es.id}}; })) //identify links relation by common id
        .force("charge" , d3.forceManyBody().strength(-50) )
        .force("center" , d3.forceCenter(width / 2, height / 2))
        .force("collide", d3.forceCollide().radius(function(d) { return d.r + 0.5; }).iterations(2)) // COLLIDE FORCE / WORKING ? ///////////////////
        ;
    
    //////////////////////////////////////////////
    
    var allEdges = [];
    var allNodes = [];
    
    
    var optArray = [];

    //initialize graph layout : fill allNodes and allEdges
    d3.json("{{ data_JSON }}",
              function(error, graph) {
                if (error) throw error   ;
                
                allNodes = graph.nodes ;
                allEdges = graph.links ;
                
                for (var i = 0; i < allNodes.length - 1; i++) {
                        //console.log(allNodes[i].label);
                        optArray.push(allNodes[i].label);   
                    } ;
                
                optArray = optArray.sort();
                //console.log("optArray from start : ", optArray);

                render(allNodes, allEdges) ;
              }
      )
    ;
    
    //console.log("optArray : ", optArray); // OK /////////////////////////
    
    /////////////////////////////////////////////////////////////////////////////////

    /// BREAK LINKS & UPDATE function
    // adapted from  :  http://bl.ocks.org/csesivakumar/31e23b875f260622f8f7da3ae380958c
    function Update_Node(buttonId){
      
      
      // get button attributes
      var Clickbutton = document.getElementById(buttonId);
      var status = Clickbutton.getAttribute("Enabled");
      
      // change button status on click event / Enabled="0" -> not clicked ; 1 = 
      if (status =="0"){
		Clickbutton.setAttribute("Enabled","1");
		Clickbutton.setAttribute("aria-pressed", "true") ;
      }
      if (status =="1"){
        Clickbutton.setAttribute("Enabled","0");
        Clickbutton.setAttribute("aria-pressed", "false") ;
      }
      
      // check status for all buttons
      var buttons = document.getElementsByClassName('breakFilter');
      //console.log("buttons :", buttons);
      
      // stores criterias to hide
      var rulesToHide = [] ;
      for(var j = 0; j < buttons.length; j++) {
        //console.log(button);
		var button = buttons[j];		
		var status = button.getAttribute("Enabled");
        // remove nodes and edges if button status is "1"
		if (status=="1"){ 
          rulesToHide.push(button.id);
        }			
      }
      //console.log("rulesToHide :", rulesToHide);
      
      var tempNodes = [];
      var tempEdges = [];
      
      // filter nodes
      for (var i = 0 ; i < allNodes.length; i++ ) {
        var obj = allNodes[i];
        if ( rulesToHide.indexOf(obj.category) == -1 ) { /// "!= -1" : in array / "== -1" : NOT in array 
          tempNodes.push(obj) ;
        }
      }
      
      // filter edges
      for (var i = 0 ; i < allEdges.length; i++ ) {
        var obj = allEdges[i];
        //console.log(obj.group);
        if ( rulesToHide.indexOf(obj.group) == -1 ) {
          //console.log(obj.group);
          tempEdges.push(obj);
        }
      }
      
      render(tempNodes, tempEdges) ;
      
    }



    // HIDE NODES FROM LAYOUT (but no disappear)
    function hideNodes(buttonValue) {

      // get button attributes
      var Clickbutton = document.getElementById(buttonValue);
      var status = Clickbutton.getAttribute("Enabled");
      
      // change button status on click event / Enabled="0" -> not clicked ; 1 = 
      if (status =="0"){
		Clickbutton.setAttribute("Enabled","1");
		Clickbutton.setAttribute("aria-pressed", "true") ;
      }
      if (status =="1"){
        Clickbutton.setAttribute("Enabled","0");
        Clickbutton.setAttribute("aria-pressed", "false") ;
      }

      // check status for all buttons
      var buttons = document.getElementsByClassName('hideFilter');
      
      //var selected = buttonValue ;
      //console.log("selected :", this);
      
      // stores criterias to hide
      var rulesToHide = [] ;
      for(var j = 0; j < buttons.length; j++) {
        //console.log(button);
		var button = buttons[j];		
		var status = button.getAttribute("Enabled");
        // remove nodes and edges if button status is "1"
		if (status=="1"){ 
          rulesToHide.push(button.id);
        }			
      }
      
      opacity = this.enabled ? 1 : 0.1 ;
      
      var nodes = vis.selectAll(".node");
      nodes.filter(function (d, i) {
        return d.category in rulesToHide | d.group in rulesToHide  ; //| selected in d.tags ;
        }
      )
        .style("opacity", opacity);
          
    }



    // main D3 function
    function render (nodes, links) {
    
      // launch force
      simulation
          .nodes(nodes)
          .on("tick", ticked);
          
      simulation.force("link")
          .links(links);
          
      var link = links_g.selectAll(".link").data(links);
      var node = nodes_g.selectAll(".node").data(nodes);
      
      // create lines for links
      //var link = vis.append("g")
      //  .attr("class", "links")
      //  .selectAll("line")
      //  .data(links).enter()
      link.enter()
          .append("line")
          .attr("class", "link")
          .attr("stroke-width"    , dft_line_stroke_w ) //function(d) { return d.{{glob.es.weight}} ; } )
          .attr("stroke-dasharray", function(d) { return d.{{glob.es.dash}}   ; } )
        .merge(link);
      link.exit().remove();
      
      
      // create node group for nodes
      //var node = vis.append("g")
      //  .attr("class", "nodes")
      //  .selectAll(".node")
      //  .data(nodes)
      node.enter() 
          .append("circle")
          .attr("r", function(d) { return Math.sqrt(d.{{glob.ns.weight}} )*1.5 } )
          .style("fill", function (d) { return d.{{glob.ns.color}} ; }) //return color(d.{{glob.ns.type}})
          .attr("stroke-width"    , dft_circle_stroke_w )
          .attr("class"   , "node")
          .attr("label"   , function(d) { return ( d.{{glob.ns.label}}    ) })
          .attr("id"      , function(d) { return ( d.{{glob.ns.id}}       ) })
          .attr("group"   , function(d) { return ( d.{{glob.ns.group}}    ) })
          .attr("category", function(d) { return ( d.{{glob.ns.category}} ) })
          .attr("url"     , function(d) { return ( d.{{glob.ns.url}}      ) })
          .attr("type"    , function(d) { return ( d.{{glob.ns.type}}     ) })
          .attr("tags"    , function(d) { return ( d.{{glob.ns.tags}}     ) }) /////////// ????? 
          
          // normal drag function
          .call(node_normal_drag)
          //.call(node_pin_drag) /// trying pinning down node
          //.on('dblclick', releasenode_)
          .on('click'   , displayInfos)    // display node infos inside right column 
          .on('dblclick', connectedNodes) //("over") ) //Added code ... .on('click'
          
          //alternative
          //.on('mouseover', connectedNodes) //("over") ) //Added code ... .on('click'
          //.on('mouseout',  connectedNodes) //("out") )
          
          //adding tooltip in div tooltip
          //.on("mouseover", tip.show)
          //.on("mouseout", tip.hide);
          .on("mouseover", function(d) {		
            div.transition()		
              .duration(200)		
              .style("opacity", .95);		
            div.html( "<strong> "+ d.{{glob.ns.label}} + " </strong>")	
              .style("left", (d3.event.pageX + 20) + "px")		
              .style("top", (d3.event.pageY - 10) + "px");	
          })					
          .on("mouseout", function(d) {		
            div.transition()		
              .duration(500)		
              .style("opacity", 0);
              
          });
      ;
      
      
      node.exit().remove();
      
      
      
      /// CONNECTED NODES ///////////////////////////////////////////////////////////////
      //Toggle stores whether the highlighting is on
      var toggle = 0;
      //Create an array logging what is connected to what
      var linkedByID = {};
      // feed linkedById
      nodes.forEach(function (n) {
        linkedByID[n.{{glob.ns.id}} + "," + n.{{glob.ns.id}} ] = 1; });    
      links.forEach(function (e) {
        //console.log(e);
        linkedByID[e.source.{{glob.ns.id}} + "," + e.target.{{glob.ns.id}}] = 1; });
      //console.log(linkedByID); //////////////////////////////////
      
      //This function looks up whether a pair are neighbours
      function neighboring(a, b) {
        return linkedByID[a.{{glob.ns.id}} + "," + b.{{glob.ns.id}} ]; }

      var N = vis.selectAll(".node");
      var L = vis.selectAll(".link");
      
      // show connected nodes and fade others
      function connectedNodes() {
        
        if (toggle == 0) {
            
          //Reduce the opacity of all but the neighbouring nodes
          d = d3.select(this).node().__data__; 
          //console.log("d :", d3.select(this).node().__data__ ); // OK
          //console.log("node selected : ", d );
          //console.log("node selected / ID : ", d.{{glob.ns.id}});

          N.attr("stroke-width",
            function (o) { return neighboring(d, o) | neighboring(o, d) ? "2px" : "0px"; } );
          
          N.style("opacity", 
            function (o) { return neighboring(d, o) | neighboring(o, d) ? 1 : 0.4; } );
          
          L.style("opacity",
            function (o) { return d.index == o.source.index | d.index == o.target.index ? 1 : 0.4; } ); 

          L.attr("stroke-width",
            function (o) { return d.index == o.source.index | d.index == o.target.index ? "2px" : "0.3px"; } ); 
          
          //Reduce the opacity
          toggle = 1;
        }
        
        else {
          //Put them back to opacity=1
          N.style("opacity", 1);
          N.attr("stroke-width", dft_circle_stroke_w );
          
          L.style("opacity", 1);
          L.attr("stroke-width", dft_line_stroke_w);
          
          toggle = 0;
        }
        
      }

      function ticked() {
        d3.select(".links").selectAll(".link")
        //link
          .attr("x1", function(d) { return d.source.x; })
          .attr("y1", function(d) { return d.source.y; })
          .attr("x2", function(d) { return d.target.x; })
          .attr("y2", function(d) { return d.target.y; })
        ;
    
        d3.select(".nodes").selectAll(".node")
            .attr("cx", function (d) { return d.x;})
            .attr("cy", function (d) { return d.y; })
        ;
      
      }
      
    }



    
    //launch autocomplete once page loaded
    $(document).ready(function () {
        $("#search").autocomplete({ source: optArray }); 
      });

    /// search bar functions 
    function searchNode() {
      //find the node
      var selectedVal = document.getElementById('search').value;
      var node = vis.selectAll(".node");
      if (selectedVal == "none") {
        node.style("stroke", "white").style("stroke-width", "1");
      }
      else {
        var selected = node.filter(function (d, i) {
            return d.label != selectedVal;
        });
        selected.style("opacity", "0.2");
        
        var link = vis.selectAll(".links")
        link.style("opacity", "0.2");
        d3.selectAll(".node, .links")
          .transition()
          .duration(4500)
          .style("opacity", 1);
      }
    }
    //search bar / run searchNode if enter (aka keyCode==13) is pressed
    function handle(e){
      if(e.keyCode === 13){
        searchNode();
        }
    }

    // display node infos in div #nodeInfos 
    function displayInfos() {
      d = d3.select(this).node().__data__;
      d3.select('#nCategory').text(d.category);
      d3.select('#nGroup').text(d.group);
      d3.select('#nLabel').text(d.label);
      d3.select('#nType').text(d.type);
      d3.select('#nUrl')
      .attr("href", d.url)
      .attr("target", "_blank")
      .text(d.url);
      d3.select('#nTags').text(d.tags); //////////// d.tags NOT WORKING YET ///////////////////////////////////////
                         //.text(for (var i=0; i<d.tags.length; i++) { alert d.tags[i] } ); //
    }
  
  




  </script>



{% endblock %}
